#!/bin/sh

set -eu

SCRIPT_NAME=$(basename "$0")
SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)

LOG_FILE="/var/log/xconfig.log"
XORG_CONF="/etc/X11/xorg.conf"
BACKUP_DIR="/etc/X11/backup"
BACKUP_KEEP=10

LOCAL_CONFIG_DIR="$SCRIPT_DIR/cardDetect"
SYSTEM_CONFIG_DIR="/usr/local/etc/X11/cardDetect"

# Allow override via environment
NVIDIA_DRIVER_VERSION="${NVIDIA_DRIVER_VERSION:-580}"

export LC_ALL=C

###############################################################################
# Logging
###############################################################################

log() {
    ts=$(date '+%Y-%m-%d %H:%M:%S')
    lvl=$1
    shift
    printf "[%s] [%s] %s\n" "$ts" "$lvl" "$*" | tee -a "$LOG_FILE" >&2
}

###############################################################################
# rc.conf management helpers
###############################################################################

rc_conf_get() {
    key=$1
    sysrc -n "$key" 2>/dev/null || echo ""
}

rc_conf_has() {
    key=$1

    if grep "^$key=" /etc/rc.conf >/dev/null 2>&1 ; then
        return 0
    fi

    if [ -f /etc/rc.conf.local ] && grep "^$key=" /etc/rc.conf.local >/dev/null 2>&1 ; then
        return 0
    fi

    return 1
}

enable_rc_conf() {
    key=$1
    val=$2
    current=$(rc_conf_get "$key")

    if [ "$current" = "$val" ]; then
        log INFO "$key already set to $val"
    elif rc_conf_has "$key"; then
        log INFO "Updating $key from '$current' to '$val'"
        sysrc "${key}=${val}"
    else
        log INFO "Enabling $key=$val"
        sysrc "${key}=${val}"
    fi
}

start_service_safe() {
    svc=$1

    if service "$svc" onestatus >/dev/null 2>&1 ; then
        log INFO "$svc already running"
        return 0
    fi

    log INFO "Starting $svc"
    if service "$svc" start >/dev/null 2>&1 ; then
        log INFO "$svc started"
    else
        log WARN "$svc failed to start"
    fi
}

###############################################################################
# Template + backup management
###############################################################################

find_config_dir() {
    if [ -d "$LOCAL_CONFIG_DIR" ]; then
        echo "$LOCAL_CONFIG_DIR"
        return
    fi

    if [ -d "$SYSTEM_CONFIG_DIR" ]; then
        echo "$SYSTEM_CONFIG_DIR"
        return
    fi

    echo ""
}

backup_xorg_conf() {
    if [ -f "$XORG_CONF" ]; then
        mkdir -p "$BACKUP_DIR"
        ts=$(date '+%Y%m%d_%H%M%S')
        cp "$XORG_CONF" "$BACKUP_DIR/xorg.conf.$ts"
        log INFO "Backed up existing xorg.conf"

        # Prune old backups, keep only BACKUP_KEEP most recent
        # shellcheck disable=SC2012
        ls -t "$BACKUP_DIR"/xorg.conf.* 2>/dev/null | tail -n +"$((BACKUP_KEEP + 1))" | xargs rm -f 2>/dev/null || true
    fi
}

apply_config_template() {
    template=$1
    dir=$(find_config_dir)

    if [ -z "$dir" ]; then
        log ERROR "No cardDetect directory found"
        return 1
    fi

    path="$dir/$template"

    if [ ! -f "$path" ]; then
        log ERROR "Template $template not found"
        return 1
    fi

    mkdir -p "$(dirname "$XORG_CONF")"
    backup_xorg_conf
    cp "$path" "$XORG_CONF"
    log INFO "Applied template $template"
}

###############################################################################
# Offline driver install (/xdrivers)
###############################################################################

install_from_xdrivers() {
    pkgname=$1

    [ -d /xdrivers ] || return 1
    [ -f /xdrivers/drivers-list ] || return 1

    file=$(awk -v p="$pkgname" '$1 == p { print $2 }' /xdrivers/drivers-list | head -n 1)

    [ -n "$file" ] || return 1
    [ -f "/xdrivers/$file" ] || return 1

    log INFO "Installing $pkgname from offline package"
    # Note: offline packages must include all dependencies in /xdrivers
    if pkg add "/xdrivers/$file"; then
        return 0
    fi

    log WARN "Offline install failed for $pkgname (missing dependencies?)"
    return 1
}

pkg_install_wrapper() {
    pkgname=$1

    install_from_xdrivers "$pkgname" && return 0

    log INFO "Installing $pkgname from pkg"
    pkg install -y "$pkgname" && return 0

    log ERROR "Failed to install $pkgname"
    return 1
}

###############################################################################
# X server detection
###############################################################################

detect_x_server() {
    if command -v xlibre >/dev/null 2>&1 ; then
        echo xlibre
        return
    fi
    echo xorg
}

###############################################################################
# VM + GPU detection
###############################################################################

# Cache vm_guest detection result
_VM_GUEST_CACHE=""

detect_vm_guest() {
    if [ -n "$_VM_GUEST_CACHE" ]; then
        echo "$_VM_GUEST_CACHE"
        return
    fi

    if sysctl -n kern.vm_guest >/dev/null 2>&1 ; then
        _VM_GUEST_CACHE=$(sysctl -n kern.vm_guest)
    else
        _VM_GUEST_CACHE="none"
    fi
    echo "$_VM_GUEST_CACHE"
}

detect_virtualbox() {
    guest=$(detect_vm_guest)
    echo "$guest" | grep -qi vbox && return 0
    dmesg 2>/dev/null | grep -qi VirtualBox && return 0
    return 1
}

detect_vmware() {
    guest=$(detect_vm_guest)
    echo "$guest" | grep -qi vmware && return 0
    dmesg 2>/dev/null | grep -qi VMware && return 0
    return 1
}

detect_qemu() {
    guest=$(detect_vm_guest)
    echo "$guest" | grep -qi kvm && return 0
    echo "$guest" | grep -qi qemu && return 0
    dmesg 2>/dev/null | grep -qi QEMU && return 0
    return 1
}

detect_hyperv() {
    guest=$(detect_vm_guest)
    echo "$guest" | grep -qi hyperv && return 0
    dmesg 2>/dev/null | grep -qi Hyper-V && return 0
    return 1
}

detect_bhyve() {
    guest=$(detect_vm_guest)
    echo "$guest" | grep -qi bhyve && return 0
    dmesg 2>/dev/null | grep -qi bhyve && return 0
    return 1
}

detect_intel_gpu() {
    pciconf -lv 2>/dev/null | grep -A4 -Ei "vga|display" | grep -qi Intel
}

detect_amd_gpu() {
    pciconf -lv 2>/dev/null | grep -A4 -Ei "vga|display" | grep -Eiq "AMD|ATI"
}

detect_nvidia_gpu() {
    pciconf -lv 2>/dev/null | grep -A4 -Ei "vga|display" | grep -qi NVIDIA
}

# Get NVIDIA GPU PCI device IDs (returns space-separated list)
get_nvidia_device_ids() {
    pciconf -l 2>/dev/null | grep -i "chip=.*10de" | \
        sed -E 's/.*chip=0x([0-9a-fA-F]{4}).*/\1/' | tr 'A-F' 'a-f'
}

# Map NVIDIA device ID to required driver series
# Based on NVIDIA's legacy driver support matrix
# Returns: 580 (current), 470, 390, 340, or 304
nvidia_device_to_driver() {
    devid=$1
    
    # Convert to lowercase for comparison
    devid=$(echo "$devid" | tr 'A-F' 'a-f')
    
    # Extract first two hex digits (device class within NVIDIA)
    prefix=$(echo "$devid" | cut -c1-2)
    
    case "$prefix" in
        # Blackwell (RTX 50xx) - 2xxx device IDs
        2[0-9a-f])
            echo "580"
            ;;
        # Ada Lovelace (RTX 40xx) - 26xx, 27xx, 28xx
        26|27|28)
            echo "580"
            ;;
        # Ampere (RTX 30xx, A-series) - 20xx, 22xx, 23xx, 24xx, 25xx
        20|22|23|24|25)
            echo "580"
            ;;
        # Turing (RTX 20xx, GTX 16xx) - 1e/1f/21 prefix
        1e|1f|21)
            echo "580"
            ;;
        # Pascal (GTX 10xx) - 15xx, 17xx, 1b/1c/1d prefix
        15|17|1b|1c|1d)
            echo "580"
            ;;
        # Maxwell (GTX 9xx, GTX 750) - 13xx, 14xx, 17xx (some)
        13|14)
            echo "580"
            ;;
        # Kepler (GTX 6xx, 7xx) - some supported in 580, some need 470
        # GK104, GK106, GK107, GK110, GK208 etc
        # 0fxx, 10xx, 11xx, 12xx - check specific ranges
        0f|10|11|12)
            # Most Kepler GPUs work with current driver
            # But some very early Kepler need 470
            case "$devid" in
                # GK107 (GT 740, etc) - some need 470
                0fc[0-9a-f]|0fd[0-9a-f]|0fe[0-9a-f])
                    echo "580"
                    ;;
                # GK208 (GT 7xx low-end) 
                1280|1281|1282|1284|1286|1287|1288|1289|128b)
                    echo "580"
                    ;;
                *)
                    echo "580"
                    ;;
            esac
            ;;
        # Fermi (GTX 4xx, 5xx) - need 390 legacy driver
        # Device IDs: 06xx, 08xx, 0axx, 0cxx, 0dxx, 0exx
        06|08|0a|0c|0d|0e)
            echo "390"
            ;;
        # Tesla (GeForce 8xxx, 9xxx, 2xx, 3xx) - need 340 legacy
        # Device IDs: 01xx, 02xx, 03xx, 04xx, 05xx, 06xx (older)
        01|02|03|04|05)
            echo "340"
            ;;
        # NV4x/G7x (GeForce 6xxx, 7xxx) - need 304 legacy
        00)
            echo "304"
            ;;
        *)
            # Default to current driver, let it fail gracefully
            echo "580"
            ;;
    esac
}

# Auto-detect best driver for installed NVIDIA GPU
auto_detect_nvidia_driver() {
    device_ids=$(get_nvidia_device_ids)
    
    if [ -z "$device_ids" ]; then
        echo "580"
        return
    fi
    
    # If multiple GPUs, find the lowest common driver version
    min_driver="580"
    
    for devid in $device_ids; do
        driver=$(nvidia_device_to_driver "$devid")
        
        # Lower version = older GPU = more restrictive
        case "$driver" in
            304)
                min_driver="304"
                ;;
            340)
                [ "$min_driver" != "304" ] && min_driver="340"
                ;;
            390)
                case "$min_driver" in
                    304|340) ;;
                    *) min_driver="390" ;;
                esac
                ;;
            470)
                case "$min_driver" in
                    304|340|390) ;;
                    *) min_driver="470" ;;
                esac
                ;;
        esac
    done
    
    echo "$min_driver"
}

count_gpu_devices() {
    # Count actual VGA/display class devices, not grep matches
    pciconf -lv 2>/dev/null | grep -Ei "^[a-z].*class.*=.*vga|^[a-z].*class.*=.*display" | wc -l | tr -d ' '
}

detect_hybrid_gpu() {
    # True hybrid = multiple GPU devices from different vendors
    gpu_count=$(count_gpu_devices)
    [ "$gpu_count" -gt 1 ] || return 1

    # Check which vendors are present
    has_intel=0
    has_amd=0
    has_nvidia=0

    pciconf -lv 2>/dev/null | grep -B1 -A3 -Ei "class.*=.*(vga|display)" | grep -qi Intel && has_intel=1
    pciconf -lv 2>/dev/null | grep -B1 -A3 -Ei "class.*=.*(vga|display)" | grep -Eiq "AMD|ATI" && has_amd=1
    pciconf -lv 2>/dev/null | grep -B1 -A3 -Ei "class.*=.*(vga|display)" | grep -qi NVIDIA && has_nvidia=1

    # Hybrid = Intel+NVIDIA, Intel+AMD, or AMD integrated+discrete
    vendor_count=$((has_intel + has_amd + has_nvidia))
    [ "$vendor_count" -gt 1 ]
}

###############################################################################
# NVIDIA driver selection
###############################################################################

select_nvidia_pkg() {
    server=$(detect_x_server)
    prefix="nvidia-driver"

    if [ "$server" = "xlibre" ]; then
        prefix="xlibre-nvidia-driver"
    fi

    # Determine driver version to use
    driver_version="$NVIDIA_DRIVER_VERSION"
    
    # If not explicitly set (still default), auto-detect based on GPU
    if [ "$driver_version" = "580" ] && [ -z "${NVIDIA_DRIVER_VERSION_SET:-}" ]; then
        detected=$(auto_detect_nvidia_driver)
        if [ "$detected" != "580" ]; then
            log INFO "Auto-detected legacy GPU, using driver series: $detected"
            driver_version="$detected"
        fi
    fi

    # If user specified a full version (contains '.'), use it directly
    case "$driver_version" in
        *.*)
            echo "${prefix}-${driver_version}"
            return
            ;;
    esac

    # Search for matching package by major version
    # For legacy drivers (304, 340, 390, 470), include them in search
    match=$(pkg search -q "^${prefix}-${driver_version}" 2>/dev/null | \
            grep -v -- "-devel" | \
            head -n 1)

    if [ -n "$match" ]; then
        echo "$match"
        return
    fi

    # Fallback: if requested version not found, try to find ANY matching driver
    # For legacy drivers, this is critical - don't exclude them
    case "$driver_version" in
        304|340|390|470)
            # Legacy driver not found - this is an error
            log ERROR "Legacy driver ${driver_version} not found in packages"
            echo "${prefix}-${driver_version}"
            return
            ;;
    esac

    # For current drivers, try the latest non-legacy driver
    match=$(pkg search -q "^${prefix}-[0-9]" 2>/dev/null | \
            grep -Ev -- "-(304|340|390|470|devel)" | \
            sort -t- -k3 -V | \
            tail -n 1)

    if [ -n "$match" ]; then
        log WARN "Requested driver ${driver_version} not found, using $match"
        echo "$match"
        return
    fi

    # Last resort: return what was requested, let pkg fail with clear error
    echo "${prefix}-${driver_version}"
}

###############################################################################
# Setup functions
###############################################################################

setup_intel_config() {
    log INFO "Configuring Intel GPU (template)"
    apply_config_template "XF86Config.intel" || return 1
}

setup_intel_auto() {
    log INFO "Intel auto mode — no xorg.conf"
    backup_xorg_conf
    rm -f "$XORG_CONF"
}

setup_amd_auto() {
    log INFO "Auto-selecting AMD driver"
    apply_config_template "XF86Config.amdgpu" && return 0
    apply_config_template "XF86Config.radeonkms" && return 0
    log ERROR "No AMD templates available"
    return 1
}

setup_amdgpu() {
    apply_config_template "XF86Config.amdgpu" || return 1
}

setup_radeonkms() {
    apply_config_template "XF86Config.radeonkms" || return 1
}

setup_nvidia() {
    pkg=$(select_nvidia_pkg)
    log INFO "Installing NVIDIA driver: $pkg"
    pkg_install_wrapper "$pkg" || log WARN "NVIDIA installation failed"

    backup_xorg_conf
    rm -f "$XORG_CONF"
    log INFO "NVIDIA autoconfiguration enabled"
}

###############################################################################
# Enhanced VirtualBox Support
###############################################################################

setup_virtualbox() {
    log INFO "Setting up VirtualBox environment"

    apply_config_template "XF86Config.virtualbox" || \
        log WARN "VirtualBox template missing"

    # Enable required rc.conf settings
    enable_rc_conf "vboxguest_enable" "YES"
    enable_rc_conf "vboxservice_enable" "YES"

    # Start services
    start_service_safe "vboxguest"
    start_service_safe "vboxservice"
}

setup_vmware() {
    log INFO "VMware configuration"
    apply_config_template "XF86Config.vmware" || return 1
}

setup_qemu() {
    log INFO "QEMU/KVM configuration"
    apply_config_template "XF86Config.qemu" || return 1
}

setup_hyperv() {
    log INFO "Hyper-V configuration"
    apply_config_template "XF86Config.hyperv" || return 1
}

setup_bhyve() {
    log INFO "bhyve guest detected"
    apply_config_template "XF86Config.bhyve" && return 0
    apply_config_template "XF86Config.scfb" || return 1
}

setup_scfb() {
    apply_config_template "XF86Config.scfb" || return 1
}

setup_vesa() {
    apply_config_template "XF86Config.vesa" || return 1
}

setup_safe() {
    apply_config_template "XF86Config.safe" || return 1
}

setup_dual() {
    apply_config_template "XF86Config.dual" || return 1
}

###############################################################################
# Auto mode
###############################################################################

cmd_auto() {
    log INFO "Running automatic detection"

    if detect_virtualbox ; then
        log INFO "Detected VirtualBox"
        setup_virtualbox
        return 0
    fi

    if detect_vmware ; then
        log INFO "Detected VMware"
        setup_vmware
        return $?
    fi

    if detect_qemu ; then
        log INFO "Detected QEMU/KVM"
        setup_qemu
        return $?
    fi

    if detect_hyperv ; then
        log INFO "Detected Hyper-V"
        setup_hyperv
        return $?
    fi

    if detect_bhyve ; then
        log INFO "Detected bhyve"
        setup_bhyve
        return $?
    fi

    # For hybrid graphics, prefer discrete GPU over integrated
    # User can manually select 'dual' if multi-monitor across GPUs is needed
    if detect_hybrid_gpu ; then
        log INFO "Detected hybrid graphics (multiple GPUs from different vendors)"
        log INFO "Selecting discrete GPU; use 'dual' command for multi-GPU output"
    fi

    # Priority: NVIDIA > AMD > Intel (discrete over integrated)
    if detect_nvidia_gpu ; then
        log INFO "Detected NVIDIA GPU"
        setup_nvidia
        return 0
    fi

    if detect_amd_gpu ; then
        log INFO "Detected AMD GPU"
        setup_amd_auto
        return $?
    fi

    if detect_intel_gpu ; then
        log INFO "Detected Intel GPU"
        setup_intel_config
        return $?
    fi

    log WARN "No supported GPU found — using scfb"
    setup_scfb
}

###############################################################################
# Debug
###############################################################################

cmd_debug() {
    echo "===== xconfig debug ====="
    echo "kern.vm_guest: $(detect_vm_guest)"
    echo "Detected X server: $(detect_x_server)"
    echo "NVIDIA driver version setting: $NVIDIA_DRIVER_VERSION"
    echo "NVIDIA auto-detected driver: $(auto_detect_nvidia_driver)"
    echo "NVIDIA device IDs: $(get_nvidia_device_ids)"
    echo "NVIDIA package selected: $(select_nvidia_pkg)"
    echo

    echo "GPU devices found: $(count_gpu_devices)"
    echo "GPU detection output:"
    pciconf -lv | grep -B1 -A3 -Ei "class.*=.*(vga|display)" || echo "No GPU found"
    echo

    echo "GPU vendor detection:"
    echo "  Intel:  $(detect_intel_gpu && echo "yes" || echo "no")"
    echo "  AMD:    $(detect_amd_gpu && echo "yes" || echo "no")"
    echo "  NVIDIA: $(detect_nvidia_gpu && echo "yes" || echo "no")"
    echo "  Hybrid: $(detect_hybrid_gpu && echo "yes" || echo "no")"
    echo

    echo "Available templates:"
    dir=$(find_config_dir)
    if [ -n "$dir" ]; then ls -1 "$dir"; else echo "None"; fi
    echo

    echo "Backup directory ($BACKUP_DIR):"
    if [ -d "$BACKUP_DIR" ]; then
        ls -lt "$BACKUP_DIR" | head -n "$((BACKUP_KEEP + 1))"
    else
        echo "  (not created yet)"
    fi
    echo "===== end of debug ====="
}

###############################################################################
# Usage
###############################################################################

usage() {
cat <<EOF
Usage: $SCRIPT_NAME <command>

Commands:
  auto          Detect and configure automatically
  intel         Intel GPU (template)
  intel-auto    Intel GPU (no xorg.conf)
  amd           Auto-select AMD (amdgpu/radeonkms)
  amdgpu        Force AMDGPU
  radeonkms     Force radeonkms
  nvidia        NVIDIA (auto)
  virtualbox    VirtualBox guest
  vmware        VMware guest
  qemu          QEMU/KVM guest
  hyperv        Hyper-V guest
  bhyve         bhyve (scfb fallback)
  vesa          VESA
  scfb          Framebuffer
  safe          Minimal
  dual          Multi-GPU output (for displays on separate GPUs)
  debug         Diagnostic dump
  help          Show this help

Environment:
  NVIDIA_DRIVER_VERSION   NVIDIA driver major (580, 470, 390, 340, 304)
                          or full version (580.105.08). Auto-detected
                          from GPU hardware if not set.
                          Set NVIDIA_DRIVER_VERSION_SET=1 to force
                          your chosen version over auto-detection.

EOF
}

###############################################################################
# Main
###############################################################################

main() {
    cmd=${1:-auto}

    case "$cmd" in
        auto)        cmd_auto ;;
        intel)       setup_intel_config ;;
        intel-auto)  setup_intel_auto ;;
        amd)         setup_amd_auto ;;
        amdgpu)      setup_amdgpu ;;
        radeonkms)   setup_radeonkms ;;
        nvidia)      setup_nvidia ;;
        virtualbox)  setup_virtualbox ;;
        vmware)      setup_vmware ;;
        qemu)        setup_qemu ;;
        hyperv)      setup_hyperv ;;
        bhyve)       setup_bhyve ;;
        vesa)        setup_vesa ;;
        scfb)        setup_scfb ;;
        safe)        setup_safe ;;
        dual)        setup_dual ;;
        debug)       cmd_debug ;;
        help|-h|--help) usage ;;
        *)
            log ERROR "Unknown command: $cmd"
            usage
            exit 1
            ;;
    esac
}

main "$@"
