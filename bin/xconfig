#!/bin/sh
#
# xconfig - Intelligent X11 configuration tool for GhostBSD / FreeBSD
#
# - Detects GPUs and common hypervisors
# - Installs appropriate drivers (optionally from /xdrivers)
# - Applies tuned Xorg configuration templates
# - Supports Xorg and XLibre X servers
#
# This version includes explicit bhyve detection which maps to the scfb template.
#

set -eu

SCRIPT_NAME=$(basename "$0")
SCRIPT_DIR=$(dirname "$(readlink -f "$0" 2>/dev/null || echo "$0")")

LOG_FILE="/var/log/xconfig.log"
XORG_CONF="/etc/X11/xorg.conf"
BACKUP_DIR="/etc/X11/backup"

# Where to look for cardDetect templates
LOCAL_CONFIG_DIR="$SCRIPT_DIR/cardDetect"
SYSTEM_CONFIG_DIR="/usr/local/etc/X11/cardDetect"

# Default to POSIX locale for predictable dialog output
export LC_ALL=C

###############################################################################
# Logging
###############################################################################

log() {
    level=$1
    shift || true
    ts=$(date '+%Y-%m-%d %H:%M:%S')
    msg=$*
    printf '[%s] [%s] %s\n' "$ts" "$level" "$msg" | tee -a "$LOG_FILE" >&2
}

###############################################################################
# Helpers: config directory, backup, application
###############################################################################

find_config_dir() {
    if [ -d "$LOCAL_CONFIG_DIR" ]; then
        echo "$LOCAL_CONFIG_DIR"
        return 0
    fi
    if [ -d "$SYSTEM_CONFIG_DIR" ]; then
        echo "$SYSTEM_CONFIG_DIR"
        return 0
    fi
    echo ""
    return 1
}

backup_xorg_conf() {
    if [ -f "$XORG_CONF" ]; then
        mkdir -p "$BACKUP_DIR"
        ts=$(date '+%Y%m%d_%H%M%S')
        backup="$BACKUP_DIR/xorg.conf.$ts"
        cp "$XORG_CONF" "$backup"
        log INFO "Backed up existing $XORG_CONF to $backup"
    fi
}

apply_config_template() {
    template_name=$1

    CONFIG_DIR=$(find_config_dir || true)
    if [ -z "$CONFIG_DIR" ]; then
        log ERROR "No cardDetect directory found. Tried: $LOCAL_CONFIG_DIR and $SYSTEM_CONFIG_DIR"
        log ERROR "Cannot apply template $template_name"
        return 1
    fi

    template_path="$CONFIG_DIR/$template_name"
    if [ ! -f "$template_path" ]; then
        log ERROR "Template $template_name not found in $CONFIG_DIR"
        return 1
    fi

    mkdir -p "$(dirname "$XORG_CONF")"
    backup_xorg_conf
    cp "$template_path" "$XORG_CONF"
    log INFO "Applied template $template_name to $XORG_CONF"
    return 0
}

###############################################################################
# Helpers: /xdrivers offline installs and pkg
###############################################################################

install_from_xdrivers() {
    pkgname=$1

    if [ ! -d /xdrivers ]; then
        return 1
    fi
    if [ ! -f /xdrivers/drivers-list ]; then
        return 1
    fi

    # Format: "<pkgname> <filename.pkg>"
    filename=$(awk -v p="$pkgname" '$1 == p {print $2}' /xdrivers/drivers-list | head -n 1)
    if [ -z "$filename" ]; then
        return 1
    fi

    pkgpath="/xdrivers/$filename"
    if [ ! -f "$pkgpath" ]; then
        log WARN "Entry for $pkgname found in /xdrivers/drivers-list but $pkgpath is missing"
        return 1
    fi

    log INFO "Installing $pkgname from offline package $pkgpath"
    if pkg add "$pkgpath"; then
        return 0
    fi

    log WARN "Offline install from $pkgpath failed for $pkgname"
    return 1
}

pkg_install_wrapper() {
    pkgname=$1

    if install_from_xdrivers "$pkgname"; then
        return 0
    fi

    log INFO "Installing $pkgname from pkg repositories"
    if pkg install -y "$pkgname"; then
        return 0
    fi

    log ERROR "Failed to install package $pkgname"
    return 1
}

###############################################################################
# X server detection: Xorg vs XLibre
###############################################################################

detect_x_server() {
    # Returns: "xorg" or "xlibre"
    if command -v xlibre >/dev/null 2>&1; then
        echo "xlibre"
        return 0
    fi

    if [ -x /usr/local/bin/xlibre ]; then
        echo "xlibre"
        return 0
    fi

    # Default to Xorg
    echo "xorg"
    return 0
}

###############################################################################
# Hardware detection helpers
###############################################################################

detect_vm_guest() {
    # Print kern.vm_guest if available
    if sysctl -n kern.vm_guest >/dev/null 2>&1; then
        sysctl -n kern.vm_guest
        return 0
    fi
    echo "none"
    return 0
}

detect_virtualbox() {
    guest=$(detect_vm_guest)
    if echo "$guest" | grep -qi "vbox"; then
        return 0
    fi
    if dmesg 2>/dev/null | grep -qi "VirtualBox"; then
        return 0
    fi
    return 1
}

detect_vmware() {
    guest=$(detect_vm_guest)
    if echo "$guest" | grep -qi "vmware"; then
        return 0
    fi
    if dmesg 2>/dev/null | grep -qi "VMware"; then
        return 0
    fi
    return 1
}

detect_qemu() {
    guest=$(detect_vm_guest)
    if echo "$guest" | grep -qi "kvm"; then
        return 0
    fi
    if echo "$guest" | grep -qi "qemu"; then
        return 0
    fi
    if dmesg 2>/dev/null | grep -qi "QEMU"; then
        return 0
    fi
    return 1
}

detect_hyperv() {
    guest=$(detect_vm_guest)
    if echo "$guest" | grep -qi "hyperv"; then
        return 0
    fi
    if dmesg 2>/dev/null | grep -qi "Hyper-V"; then
        return 0
    fi
    return 1
}

detect_bhyve() {
    guest=$(detect_vm_guest)
    if echo "$guest" | grep -qi "bhyve"; then
        return 0
    fi
    # Secondary heuristic if needed
    if dmesg 2>/dev/null | grep -qi "bhyve"; then
        return 0
    fi
    return 1
}

detect_intel_gpu() {
    if pciconf -lv 2>/dev/null | grep -A4 -Ei "vga|display" | grep -qi "Intel"; then
        return 0
    fi
    return 1
}

detect_amd_gpu() {
    if pciconf -lv 2>/dev/null | grep -A4 -Ei "vga|display" | grep -Eiq "AMD|ATI"; then
        return 0
    fi
    return 1
}

detect_nvidia_gpu() {
    if pciconf -lv 2>/dev/null | grep -A4 -Ei "vga|display" | grep -qi "NVIDIA"; then
        return 0
    fi
    return 1
}

###############################################################################
# NVIDIA branch selection (heuristic, simplified)
###############################################################################

select_nvidia_pkg() {
    # This is a simplified heuristic. You may refine with pciconf parsing.
    # Default to the newest branch and fall back if not available.
    server=$(detect_x_server)
    base_pkg="nvidia-driver-580"

    if [ "$server" = "xlibre" ]; then
        base_pkg="xlibre-nvidia-driver-580"
    fi

    # Try a sequence until one is installable
    candidates="580 470 390 340 304"
    for v in $candidates; do
        pkgname="nvidia-driver-$v"
        if [ "$server" = "xlibre" ]; then
            pkgname="xlibre-$pkgname"
        fi
        echo "$pkgname"
        return 0
    done

    # Fallback to generic name
    if [ "$server" = "xlibre" ]; then
        echo "xlibre-nvidia-driver"
    else
        echo "nvidia-driver"
    fi
}

###############################################################################
# Setup functions
###############################################################################

setup_intel_config() {
    log INFO "Setting up Intel GPU (external XF86Config.intel)"
    apply_config_template "XF86Config.intel"
    log INFO "Intel configuration applied"
}

setup_intel_auto() {
    log INFO "Setting up Intel GPU (auto, no config file)"
    # In auto mode we rely on Xorg autodetection. No xorg.conf required.
    backup_xorg_conf
    rm -f "$XORG_CONF"
    log INFO "Removed $XORG_CONF so Intel can auto configure"
}

setup_amd_auto() {
    log INFO "Auto selecting AMD driver (amdgpu or radeonkms)"
    # Very simple heuristic: prefer amdgpu, fall back to radeonkms
    if apply_config_template "XF86Config.amdgpu"; then
        log INFO "Applied amdgpu template"
        return 0
    fi
    if apply_config_template "XF86Config.radeonkms"; then
        log INFO "Applied radeonkms template"
        return 0
    fi
    log ERROR "No suitable AMD template found"
    return 1
}

setup_amdgpu() {
    log INFO "Forcing AMDGPU template"
    apply_config_template "XF86Config.amdgpu"
}

setup_radeonkms() {
    log INFO "Forcing radeonkms template"
    apply_config_template "XF86Config.radeonkms"
}

setup_nvidia() {
    log INFO "Setting up NVIDIA GPU"
    pkgname=$(select_nvidia_pkg)
    log INFO "Selected NVIDIA package: $pkgname"
    pkg_install_wrapper "$pkgname" || log WARN "NVIDIA driver installation failed"

    # NVIDIA usually autoconfigures; leave xorg.conf minimal or absent.
    backup_xorg_conf
    rm -f "$XORG_CONF"
    log INFO "Removed $XORG_CONF so NVIDIA Xorg can auto configure"
}

setup_virtualbox() {
    log INFO "Setting up VirtualBox guest"
    apply_config_template "XF86Config.virtualbox" || log WARN "Failed to apply VirtualBox template"
}

setup_vmware() {
    log INFO "Setting up VMware guest"
    apply_config_template "XF86Config.vmware" || log WARN "Failed to apply VMware template"
}

setup_qemu() {
    log INFO "Setting up QEMU/KVM guest"
    apply_config_template "XF86Config.qemu" || log WARN "Failed to apply QEMU template"
}

setup_hyperv() {
    log INFO "Setting up Hyper-V guest"
    apply_config_template "XF86Config.hyperv" || log WARN "Failed to apply Hyper-V template"
}

setup_bhyve() {
    log INFO "Setting up bhyve guest using scfb"
    # You can either reuse scfb or create a dedicated XF86Config.bhyve
    if apply_config_template "XF86Config.bhyve"; then
        log INFO "Applied XF86Config.bhyve"
        return 0
    fi
    log INFO "XF86Config.bhyve not found. Falling back to XF86Config.scfb"
    apply_config_template "XF86Config.scfb"
}

setup_scfb() {
    log INFO "Setting up scfb (framebuffer) configuration"
    apply_config_template "XF86Config.scfb"
}

setup_vesa() {
    log INFO "Setting up VESA configuration"
    apply_config_template "XF86Config.vesa"
}

setup_safe() {
    log INFO "Setting up safe minimal configuration"
    apply_config_template "XF86Config.safe"
}

setup_dual() {
    log INFO "Setting up dual monitor configuration"
    apply_config_template "XF86Config.dual"
}

###############################################################################
# Dialog helpers (bsddialog preferred)
###############################################################################

have_bsddialog() {
    command -v bsddialog >/dev/null 2>&1
}

have_dialog() {
    command -v dialog >/dev/null 2>&1
}

interactive_menu() {
    title=$1
    shift

    if have_bsddialog; then
        bsddialog --title "$title" --menu "Select an option:" 0 0 0 "$@" 2>&1 1>/dev/tty
        return $?
    fi

    if have_dialog; then
        dialog --title "$title" --menu "Select an option:" 0 0 0 "$@" 2> /tmp/xconfig-menu.$$ 1>/dev/tty
        rc=$?
        choice=$(cat /tmp/xconfig-menu.$$ 2>/dev/null || true)
        rm -f /tmp/xconfig-menu.$$ || true
        if [ $rc -ne 0 ]; then
            return $rc
        fi
        printf '%s\n' "$choice"
        return 0
    fi

    log ERROR "Neither bsddialog nor dialog is available for interactive mode"
    return 1
}

run_interactive() {
    # Build menu entries
    set -- \
        "auto"      "Automatic detection and configuration" \
        "intel"     "Intel GPU with external config" \
        "intel-auto" "Intel GPU (auto, no config file)" \
        "amd"       "AMD auto (amdgpu or radeonkms)" \
        "amdgpu"    "Force amdgpu" \
        "radeonkms" "Force radeonkms" \
        "nvidia"    "NVIDIA (auto branch selection)" \
        "virtualbox" "VirtualBox guest" \
        "vmware"    "VMware guest" \
        "qemu"      "QEMU/KVM guest" \
        "hyperv"    "Microsoft Hyper-V guest" \
        "bhyve"     "bhyve guest (scfb)" \
        "vesa"      "Generic VESA" \
        "scfb"      "Framebuffer (scfb)" \
        "safe"      "Safe minimal configuration" \
        "dual"      "Dual monitor template" \
        "quit"      "Exit without changes"

    choice=$(interactive_menu "xconfig" "$@") || return 1

    case $choice in
        auto)       cmd_auto ;;
        intel)      setup_intel_config ;;
        intel-auto) setup_intel_auto ;;
        amd)        setup_amd_auto ;;
        amdgpu)     setup_amdgpu ;;
        radeonkms)  setup_radeonkms ;;
        nvidia)     setup_nvidia ;;
        virtualbox) setup_virtualbox ;;
        vmware)     setup_vmware ;;
        qemu)       setup_qemu ;;
        hyperv)     setup_hyperv ;;
        bhyve)      setup_bhyve ;;
        vesa)       setup_vesa ;;
        scfb)       setup_scfb ;;
        safe)       setup_safe ;;
        dual)       setup_dual ;;
        quit)       log INFO "User requested quit. No changes made." ;;
        *)          log ERROR "Unknown selection $choice" ;;
    esac
}

###############################################################################
# Auto mode logic
###############################################################################

cmd_auto() {
    log INFO "Running automatic detection"

    xserver=$(detect_x_server)
    log INFO "Detected X server: $xserver"

    # Hypervisors first
    if detect_virtualbox; then
        log INFO "Detected VirtualBox guest"
        setup_virtualbox
        return 0
    fi

    if detect_vmware; then
        log INFO "Detected VMware guest"
        setup_vmware
        return 0
    fi

    if detect_qemu; then
        log INFO "Detected QEMU/KVM guest"
        setup_qemu
        return 0
    fi

    if detect_hyperv; then
        log INFO "Detected Hyper-V guest"
        setup_hyperv
        return 0
    fi

    if detect_bhyve; then
        log INFO "Detected bhyve guest"
        setup_bhyve
        return 0
    fi

    # Physical GPUs
    if detect_intel_gpu; then
        log INFO "Detected Intel GPU"
        setup_intel_config
        return 0
    fi

    if detect_amd_gpu; then
        log INFO "Detected AMD GPU"
        setup_amd_auto
        return 0
    fi

    if detect_nvidia_gpu; then
        log INFO "Detected NVIDIA GPU"
        setup_nvidia
        return 0
    fi

    # Fallback
    log WARN "Could not identify a supported GPU or hypervisor. Falling back to scfb"
    setup_scfb
}

###############################################################################
# Debug
###############################################################################

cmd_debug() {
    echo "===== xconfig debug ====="
    echo "Script:          $SCRIPT_NAME"
    echo "Script dir:      $SCRIPT_DIR"
    echo "Config dirs:     $LOCAL_CONFIG_DIR, $SYSTEM_CONFIG_DIR"
    echo "Xorg conf:       $XORG_CONF"
    echo "Backup dir:      $BACKUP_DIR"
    echo

    echo "FreeBSD version:"
    freebsd-version -kru 2>/dev/null || uname -a
    echo

    echo "kern.vm_guest:"
    detect_vm_guest
    echo

    echo "Detected GPUs (pciconf):"
    pciconf -lv 2>/dev/null | grep -A4 -Ei "vga|display" || echo "No VGA/display controllers found"
    echo

    echo "X server detection:"
    detect_x_server
    echo

    echo "Available templates:"
    CONFIG_DIR=$(find_config_dir || true)
    if [ -n "$CONFIG_DIR" ]; then
        ls -1 "$CONFIG_DIR"
    else
        echo "No cardDetect directory found"
    fi
    echo

    if [ -d /xdrivers ]; then
        echo "/xdrivers exists"
        if [ -f /xdrivers/drivers-list ]; then
            echo "drivers-list:"
            cat /xdrivers/drivers-list
        else
            echo "drivers-list not present"
        fi
    else
        echo "/xdrivers does not exist"
    fi

    echo "===== end of debug ====="
}

###############################################################################
# Usage
###############################################################################

usage() {
    cat <<EOF
Usage: $SCRIPT_NAME <command>

Commands:
  auto          Automatic detection and configuration
  setup         Interactive setup (same as manual)
  manual        Interactive setup using bsddialog or dialog
  intel         Intel GPU with external config (XF86Config.intel)
  intel-auto    Intel GPU auto. No xorg.conf file
  amd           AMD auto (amdgpu or radeonkms)
  amdgpu        Force amdgpu template
  radeonkms     Force radeonkms template
  nvidia        NVIDIA configuration with driver install
  virtualbox    VirtualBox guest configuration
  vmware        VMware guest configuration
  qemu          QEMU/KVM guest configuration
  hyperv        Hyper-V guest configuration
  bhyve         bhyve guest. Uses XF86Config.bhyve if present, otherwise scfb
  vesa          Generic VESA configuration
  scfb          Generic framebuffer configuration
  safe          Safe minimal configuration
  dual          Dual monitor template
  debug         Print diagnostic information
  help          Show this help message

Examples:
  sudo $SCRIPT_NAME auto
  sudo $SCRIPT_NAME intel
  sudo $SCRIPT_NAME bhyve

EOF
}

###############################################################################
# Main
###############################################################################

main() {
    cmd=${1:-auto}

    case $cmd in
        auto)
            cmd_auto
            ;;
        setup|manual)
            run_interactive
            ;;
        intel)
            setup_intel_config
            ;;
        intel-auto)
            setup_intel_auto
            ;;
        amd)
            setup_amd_auto
            ;;
        amdgpu)
            setup_amdgpu
            ;;
        radeonkms)
            setup_radeonkms
            ;;
        nvidia)
            setup_nvidia
            ;;
        virtualbox)
            setup_virtualbox
            ;;
        vmware)
            setup_vmware
            ;;
        qemu)
            setup_qemu
            ;;
        hyperv)
            setup_hyperv
            ;;
        bhyve)
            setup_bhyve
            ;;
        vesa)
            setup_vesa
            ;;
        scfb)
            setup_scfb
            ;;
        safe)
            setup_safe
            ;;
        dual)
            setup_dual
            ;;
        debug)
            cmd_debug
            ;;
        help|-h|--help)
            usage
            ;;
        *)
            log ERROR "Unknown command: $cmd"
            usage
            exit 1
            ;;
    esac
}

main "$@"
