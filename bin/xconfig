#!/bin/sh

# Complete X Configuration Script for GhostBSD/FreeBSD
# POSIX sh compatible - works with sh, zsh, fish
# Uses X -configure -ignoreABI consistently for better compatibility

set -e
umask 022

# Configuration
SCRIPT_NAME="$(basename "$0")"
LOG_FILE="/var/log/xconfig.log"
XORG_CONF="/etc/X11/xorg.conf"
BACKUP_DIR="/etc/X11/backup"

# Logging with structured output
log() {
    local level="$1"
    shift
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    printf "[%s] [%s] %s\n" "$timestamp" "$level" "$*" | tee -a "$LOG_FILE"
}

info() { log "INFO" "$@"; }
warn() { log "WARN" "$@"; }
error() { log "ERROR" "$@"; echo "Error: $*" >&2; }

# Check root privileges and setup environment
check_environment() {
    if [ "$(id -u)" != 0 ]; then
        echo "Error: Must be run as root" >&2
        exit 1
    fi
    
    # Ensure log and backup directories exist
    mkdir -p "$(dirname "$LOG_FILE")" "$BACKUP_DIR"
    
    info "Starting $SCRIPT_NAME (PID: $$)"
}

# Hardware detection using PCI vendor IDs
detect_hardware() {
    local pci_info
    pci_info=$(pciconf -lv 2>/dev/null) || {
        error "Cannot read PCI configuration"
        return 1
    }
    
    # Check virtualization first (highest priority)
    if echo "$pci_info" | grep -qi "virtualbox"; then
        echo "virtualbox"
    elif echo "$pci_info" | grep -qi "vmware\|vendor=0x15ad"; then
        echo "vmware"
    elif echo "$pci_info" | grep -qi "qemu\|vendor=0x1234"; then
        echo "qemu"
    # Real hardware detection using vendor IDs
    elif echo "$pci_info" | grep -q "vendor=0x10de"; then
        detect_nvidia_family "$pci_info"
    elif echo "$pci_info" | grep -q "vendor=0x8086.*vga"; then
        echo "intel"
    elif echo "$pci_info" | grep -q "vendor=0x1002"; then
        detect_amd_family "$pci_info"
    else
        echo "unknown"
    fi
}

# NVIDIA family detection using device ID ranges
detect_nvidia_family() {
    local pci_info="$1"
    local device_id
    
    device_id=$(echo "$pci_info" | grep -A1 "vendor=0x10de" | grep "device=" | head -1 | cut -d'=' -f2)
    
    if [ -z "$device_id" ]; then
        warn "Cannot determine NVIDIA device ID, using latest driver"
        echo "nvidia-latest"
        return
    fi
    
    # Convert hex to decimal for range comparison (simplified approach)
    local device_hex
    device_hex=$(echo "$device_id" | sed 's/0x//')
    
    info "NVIDIA device ID: $device_id"
    
    # Use simplified string comparison for ranges
    case "$device_hex" in
        2[8-9]*|[3-9]*)
            echo "nvidia-latest"  # RTX 50+ series (580 driver)
            ;;
        2[6-7]*)
            echo "nvidia-latest"  # RTX 40 series (580 driver)
            ;;
        2[2-5]*)
            echo "nvidia-latest"  # RTX 30 series (580 driver)
            ;;
        1[e-f]*|20*|21*)
            echo "nvidia-470"     # RTX 20/GTX 16 series
            ;;
        1[0-9a-d]*)
            echo "nvidia-390"     # GTX 10/900 series
            ;;
        [6-9]*|a*|b*|c*|d*|e*|f*)
            echo "nvidia-340"     # GTX 600-800 series
            ;;
        *)
            echo "nvidia-304"     # Legacy cards
            ;;
    esac
}

# AMD family detection
detect_amd_family() {
    local pci_info="$1"
    local device_id
    
    device_id=$(echo "$pci_info" | grep -A1 "vendor=0x1002" | grep "device=" | head -1 | cut -d'=' -f2)
    
    if [ -z "$device_id" ]; then
        warn "Cannot determine AMD device ID, using amdgpu"
        echo "amdgpu"
        return
    fi
    
    info "AMD device ID: $device_id"
    
    # Simplified AMD detection - newer cards use amdgpu
    case "$device_id" in
        0x6[9-f]*|0x7*)
            echo "amdgpu"     # Newer AMD cards
            ;;
        *)
            echo "radeonkms"  # Legacy Radeon cards
            ;;
    esac
}

# Backup existing configuration
backup_config() {
    if [ -f "$XORG_CONF" ]; then
        local backup_name="xorg.conf.$(date +%Y%m%d_%H%M%S)"
        cp "$XORG_CONF" "$BACKUP_DIR/$backup_name"
        info "Backed up existing config to $BACKUP_DIR/$backup_name"
    fi
}

# Test X configuration with consistent -ignoreABI flag
test_x_config() {
    local config_file="$1"
    local timeout="10"
    
    info "Testing X configuration: $config_file"
    
    # Test X startup with ignoreABI for better compatibility
    if timeout "$timeout" X -config "$config_file" -ignoreABI -retro >/dev/null 2>&1 &
    then
        local x_pid=$!
        sleep 2
        
        # Check if X is still running
        if kill -0 "$x_pid" 2>/dev/null; then
            kill "$x_pid" 2>/dev/null || true
            wait "$x_pid" 2>/dev/null || true
            info "X configuration test successful"
            return 0
        fi
    fi
    
    warn "X configuration test failed"
    return 1
}

# Generate generic X configuration with -ignoreABI
generate_generic_config() {
    info "Generating generic X configuration"
    
    backup_config
    
    if X -configure -ignoreABI >/tmp/xconfig.log 2>&1; then
        if [ -f /root/xorg.conf.new ]; then
            mkdir -p /etc/X11
            cp /root/xorg.conf.new "$XORG_CONF"
            info "Generic X configuration generated successfully"
            return 0
        fi
    fi
    
    warn "Failed to generate generic X configuration"
    return 1
}

# NVIDIA driver setup with real package names
setup_nvidia() {
    local driver_type="$1"
    local pkg_name module_name
    
    info "Setting up NVIDIA driver: $driver_type"
    
    # Map to actual available package names
    case "$driver_type" in
        nvidia-latest) pkg_name="nvidia-driver-580"; module_name="nvidia-modeset" ;;
        nvidia-470) pkg_name="nvidia-driver-470"; module_name="nvidia-modeset" ;;
        nvidia-390) pkg_name="nvidia-driver-390"; module_name="nvidia-modeset" ;;
        nvidia-340) pkg_name="nvidia-driver-340"; module_name="nvidia" ;;
        nvidia-304) pkg_name="nvidia-driver-304"; module_name="nvidia" ;;
        nvidia-devel) pkg_name="nvidia-driver-devel"; module_name="nvidia-modeset" ;;
        *) error "Unknown NVIDIA driver type: $driver_type"; return 1 ;;
    esac
    
    # Install driver
    install_nvidia_driver "$pkg_name" || {
        error "Failed to install $pkg_name"
        return 1
    }
    
    # Setup kernel module
    load_nvidia_module "$module_name" || {
        error "Failed to load $module_name"
        return 1
    }
    
    # Generate X configuration
    generate_nvidia_config || {
        error "Failed to generate NVIDIA X configuration"
        return 1
    }
    
    info "NVIDIA setup completed successfully"
    return 0
}

# Install NVIDIA driver with proper error handling
install_nvidia_driver() {
    local pkg_name="$1"
    
    # Check if already installed
    if pkg info "$pkg_name" >/dev/null 2>&1; then
        info "NVIDIA driver $pkg_name already installed"
        return 0
    fi
    
    # Ensure Linux compatibility
    ensure_linux_compatibility
    
    # Try /xdrivers first (GhostBSD specific)
    if [ -d "/xdrivers" ] && [ -f "/xdrivers/drivers-list" ]; then
        local driver_file
        driver_file=$(grep "^$pkg_name " /xdrivers/drivers-list 2>/dev/null | cut -d' ' -f2)
        if [ -n "$driver_file" ] && [ -f "/xdrivers/$driver_file" ]; then
            info "Installing $pkg_name from /xdrivers"
            if pkg add "/xdrivers/$driver_file"; then
                return 0
            else
                warn "Failed to install from /xdrivers, trying repository"
            fi
        fi
    fi
    
    # Install from repository
    info "Installing $pkg_name from repository"
    if pkg install -y "$pkg_name"; then
        info "Successfully installed $pkg_name"
        return 0
    fi
    
    # Show alternatives if failed
    error "Failed to install $pkg_name"
    error "Available NVIDIA drivers:"
    pkg search "^nvidia-driver-" 2>/dev/null | while read -r line; do
        error "  $line"
    done
    
    return 1
}

# Ensure Linux compatibility for NVIDIA
ensure_linux_compatibility() {
    # Enable Linux layer
    if ! sysrc -n linux_enable 2>/dev/null | grep -q "YES"; then
        info "Enabling Linux compatibility layer"
        sysrc linux_enable="YES" || warn "Failed to enable Linux compatibility"
    fi
    
    # Load Linux module
    if ! kldstat | grep -q "linux"; then
        info "Loading Linux compatibility module"
        kldload linux 2>/dev/null || kldload linux.ko 2>/dev/null || warn "Failed to load Linux module"
    fi
}

# Load NVIDIA kernel module
load_nvidia_module() {
    local module_name="$1"
    
    info "Loading NVIDIA module: $module_name"
    
    # Unload conflicting modules
    for mod in amdgpu radeonkms i915kms nvidia nvidia-modeset; do
        if kldstat | grep -q "\\b$mod\\b"; then
            kldunload "$mod" 2>/dev/null || warn "Failed to unload $mod"
        fi
    done
    
    # Load NVIDIA module
    if kldload "$module_name"; then
        sysrc kldload_nvidia="$module_name"
        info "NVIDIA module $module_name loaded successfully"
        return 0
    else
        error "Failed to load NVIDIA module: $module_name"
        return 1
    fi
}

# Generate NVIDIA X configuration with -ignoreABI
generate_nvidia_config() {
    info "Generating NVIDIA X configuration"
    
    backup_config
    
    if X -configure -ignoreABI >/tmp/nvidia-config.log 2>&1; then
        if [ -f /root/xorg.conf.new ]; then
            # Modify for NVIDIA
            sed -i.bak \
                -e 's/"nv"/"nvidia"/g' \
                -e 's/"vesa"/"nvidia"/g' \
                -e 's/"scfb"/"nvidia"/g' \
                -e 's/"modesetting"/"nvidia"/g' \
                /root/xorg.conf.new
            
            # Add server flags
            cat >> /root/xorg.conf.new << 'EOF'

Section "ServerFlags"
    Option "IgnoreABI" "1"
EndSection
EOF
            
            mkdir -p /etc/X11
            cp /root/xorg.conf.new "$XORG_CONF"
            
            # Test the configuration
            if test_x_config "$XORG_CONF"; then
                info "NVIDIA X configuration generated and tested successfully"
                return 0
            else
                warn "NVIDIA configuration generated but failed testing"
                return 0  # Still return success as config was created
            fi
        fi
    fi
    
    error "Failed to generate NVIDIA X configuration"
    return 1
}

# Intel graphics setup
setup_intel() {
    info "Setting up Intel graphics"
    
    backup_config
    
    # Unload conflicting modules
    for mod in amdgpu radeonkms nvidia nvidia-modeset; do
        if kldstat | grep -q "\\b$mod\\b"; then
            kldunload "$mod" 2>/dev/null || true
        fi
    done
    
    # Load Intel module
    if kldload i915kms >/dev/null 2>&1; then
        sysrc kld_list+="i915kms"
        info "Intel i915kms module loaded successfully"
        
        # Try to generate X config, fall back to auto-detection
        if ! generate_generic_config; then
            rm -f "$XORG_CONF"
            info "Using X auto-detection for Intel graphics"
        fi
        
        info "Intel graphics setup completed"
        return 0
    else
        warn "Failed to load i915kms module, trying auto-detection"
        rm -f "$XORG_CONF"
        return 0
    fi
}

# AMD graphics setup
setup_amd() {
    local driver_type="$1"
    
    info "Setting up AMD graphics with $driver_type driver"
    
    backup_config
    
    # Unload conflicting modules
    for mod in amdgpu radeonkms i915kms nvidia nvidia-modeset; do
        if kldstat | grep -q "\\b$mod\\b"; then
            kldunload "$mod" 2>/dev/null || true
        fi
    done
    
    # Load appropriate AMD module
    if kldload "$driver_type" >/dev/null 2>&1; then
        sysrc kld_list+="$driver_type"
        info "AMD $driver_type module loaded successfully"
        
        # Try to generate X config, fall back to auto-detection
        if ! generate_generic_config; then
            rm -f "$XORG_CONF"
            info "Using X auto-detection for AMD graphics"
        fi
        
        info "AMD graphics setup completed"
        return 0
    else
        warn "Failed to load $driver_type module"
        return 1
    fi
}

# VirtualBox guest setup
setup_virtualbox() {
    info "Setting up VirtualBox guest graphics"
    
    # Enable VirtualBox guest additions
    sysrc vboxguest_enable="YES" || warn "Failed to enable vboxguest"
    sysrc vboxservice_enable="YES" || warn "Failed to enable vboxservice"
    
    # Start services
    service vboxguest status >/dev/null 2>&1 || service vboxguest start || warn "Failed to start vboxguest"
    service vboxservice status >/dev/null 2>&1 || service vboxservice start || warn "Failed to start vboxservice"
    
    # Remove any existing X config to use auto-detection
    backup_config
    rm -f "$XORG_CONF"
    
    info "VirtualBox graphics setup completed"
    return 0
}

# VMware guest setup
setup_vmware() {
    info "Setting up VMware guest graphics"
    
    backup_config
    
    local vmware_config="/usr/local/etc/X11/cardDetect/XF86Config.vmware"
    if [ -f "$vmware_config" ]; then
        mkdir -p /etc/X11
        cp "$vmware_config" "$XORG_CONF"
        info "Applied VMware configuration"
        
        # Test VMware configuration
        if test_x_config "$XORG_CONF"; then
            info "VMware configuration tested successfully"
        else
            warn "VMware configuration failed test, falling back to VESA"
            setup_vesa_config
        fi
    else
        # Use VESA as fallback
        setup_vesa_config
    fi
    
    return 0
}

# VESA fallback configuration
setup_vesa() {
    info "Setting up VESA graphics (safe mode)"
    backup_config
    setup_vesa_config
    return 0
}

setup_vesa_config() {
    mkdir -p /etc/X11
    cat > "$XORG_CONF" << 'EOF'
Section "Device"
    Identifier "Configured Video Device"
    Driver "vesa"
EndSection

Section "Monitor"
    Identifier "Configured Monitor"
EndSection

Section "Screen"
    Identifier "Default Screen"
    Monitor "Configured Monitor"
    Device "Configured Video Device"
    DefaultDepth 24
    SubSection "Display"
        Depth 24
        Modes "1024x768" "800x600" "640x480"
    EndSubSection
EndSection

Section "ServerFlags"
    Option "IgnoreABI" "1"
EndSection
EOF
    info "VESA configuration applied with IgnoreABI option"
}

# Progressive auto-configuration
auto_configure() {
    info "Starting automatic X configuration"
    
    local hw_type
    hw_type=$(detect_hardware)
    
    info "Detected hardware: $hw_type"
    
    case "$hw_type" in
        virtualbox)
            setup_virtualbox
            ;;
        vmware)
            setup_vmware
            ;;
        qemu)
            setup_vesa  # QEMU usually works with VESA
            ;;
        nvidia-*)
            setup_nvidia "$hw_type"
            ;;
        intel)
            setup_intel
            ;;
        amdgpu|radeonkms)
            setup_amd "$hw_type"
            ;;
        *)
            warn "Unknown hardware type, using VESA fallback"
            setup_vesa
            ;;
    esac
}

# Interactive manual setup
manual_setup() {
    info "Starting manual setup"
    
    if ! command -v dialog >/dev/null 2>&1; then
        error "Dialog not available for manual setup"
        return 1
    fi
    
    while true; do
        dialog --title "X Configuration" \
        --menu "Select graphics configuration:" 18 70 14 \
        "auto" "Automatic detection (recommended)" \
        "intel" "Intel graphics" \
        "amd-auto" "AMD graphics (auto-detect driver)" \
        "amdgpu" "AMD graphics (amdgpu driver)" \
        "radeonkms" "AMD graphics (radeonkms driver)" \
        "nvidia-580" "NVIDIA graphics (580 series driver)" \
        "nvidia-470" "NVIDIA graphics (470 legacy driver)" \
        "nvidia-390" "NVIDIA graphics (390 legacy driver)" \
        "nvidia-340" "NVIDIA graphics (340 legacy driver)" \
        "nvidia-304" "NVIDIA graphics (304 legacy driver)" \
        "vesa" "VESA compatible (safe mode)" \
        "virtualbox" "VirtualBox guest" \
        "vmware" "VMware guest" \
        "test" "Test current configuration" \
        "exit" "Exit without changes" 2>/tmp/xconfig_choice || break
        
        local choice
        choice=$(cat /tmp/xconfig_choice 2>/dev/null)
        rm -f /tmp/xconfig_choice
        
        case "$choice" in
            auto)
                if auto_configure; then
                    dialog --msgbox "Automatic configuration successful!" 6 50
                    break
                else
                    dialog --msgbox "Automatic configuration failed." 6 40
                fi
                ;;
            intel)
                if setup_intel; then
                    dialog --msgbox "Intel graphics configured successfully!" 6 50
                    break
                else
                    dialog --msgbox "Intel configuration failed." 6 40
                fi
                ;;
            amd-auto)
                local amd_driver
                amd_driver=$(detect_amd_family "$(pciconf -lv)")
                if setup_amd "$amd_driver"; then
                    dialog --msgbox "AMD graphics configured successfully!" 6 50
                    break
                else
                    dialog --msgbox "AMD configuration failed." 6 40
                fi
                ;;
            amdgpu|radeonkms)
                if setup_amd "$choice"; then
                    dialog --msgbox "AMD $choice configured successfully!" 6 50
                    break
                else
                    dialog --msgbox "AMD $choice configuration failed." 6 40
                fi
                ;;
            nvidia-*)
                if setup_nvidia "nvidia-$(echo "$choice" | cut -d'-' -f2)"; then
                    dialog --msgbox "NVIDIA graphics configured successfully!" 6 50
                    break
                else
                    dialog --msgbox "NVIDIA configuration failed." 6 40
                fi
                ;;
            vesa)
                if setup_vesa; then
                    dialog --msgbox "VESA configuration successful!" 6 40
                    break
                else
                    dialog --msgbox "VESA configuration failed." 6 40
                fi
                ;;
            virtualbox)
                if setup_virtualbox; then
                    dialog --msgbox "VirtualBox configuration successful!" 6 50
                    break
                else
                    dialog --msgbox "VirtualBox configuration failed." 6 40
                fi
                ;;
            vmware)
                if setup_vmware; then
                    dialog --msgbox "VMware configuration successful!" 6 50
                    break
                else
                    dialog --msgbox "VMware configuration failed." 6 40
                fi
                ;;
            test)
                if [ -f "$XORG_CONF" ]; then
                    if test_x_config "$XORG_CONF"; then
                        dialog --msgbox "Current X configuration test passed!" 6 50
                    else
                        dialog --msgbox "Current X configuration test failed." 6 50
                    fi
                else
                    dialog --msgbox "No X configuration found to test." 6 40
                fi
                ;;
            exit)
                break
                ;;
        esac
    done
}

# System information check
check_system_state() {
    info "=== System State Check ==="
    
    # FreeBSD version
    local fbsd_version
    fbsd_version=$(freebsd-version 2>/dev/null || uname -r)
    info "FreeBSD version: $fbsd_version"
    
    # Available NVIDIA packages
    info "Available NVIDIA packages:"
    pkg search "^nvidia-driver" 2>/dev/null | head -10 | while read -r line; do
        info "  $line"
    done
    
    # Linux compatibility
    if kldstat | grep -q "linux"; then
        info "Linux compatibility: LOADED"
    else
        info "Linux compatibility: NOT LOADED"
    fi
    
    # GPU information
    local gpu_info
    gpu_info=$(pciconf -lv 2>/dev/null | grep -A2 -B2 "class=0x030000" | head -10)
    if [ -n "$gpu_info" ]; then
        info "Detected GPU:"
        echo "$gpu_info" | while read -r line; do
            info "  $line"
        done
    fi
    
    # Driver directories
    if [ -d "/xdrivers" ]; then
        local pkg_count
        pkg_count=$(ls /xdrivers/*.pkg 2>/dev/null | wc -l)
        info "Custom driver directory: /xdrivers ($pkg_count packages)"
    else
        info "Custom driver directory: NOT AVAILABLE"
    fi
    
    # Current X configuration
    if [ -f "$XORG_CONF" ]; then
        info "Current X configuration: EXISTS"
        grep -E "Driver|Identifier" "$XORG_CONF" 2>/dev/null | while read -r line; do
            info "  $line"
        done
    else
        info "Current X configuration: NOT FOUND (using auto-detection)"
    fi
    
    # Test X server responsiveness
    info "Testing X server availability..."
    if X -configure -ignoreABI >/tmp/x-test.log 2>&1; then
        info "X server: RESPONSIVE"
        rm -f /root/xorg.conf.new  # Clean up test file
    else
        warn "X server: ISSUES DETECTED"
        if [ -f /tmp/x-test.log ]; then
            info "X server errors:"
            head -5 /tmp/x-test.log | while read -r line; do
                info "  $line"
            done
        fi
    fi
}

# Main function
main() {
    local mode="${1:-auto}"
    
    check_environment
    info "X configuration mode: $mode"
    
    case "$mode" in
        auto)
            if auto_configure; then
                info "Automatic configuration completed successfully"
            else
                error "Automatic configuration failed"
                if command -v dialog >/dev/null 2>&1; then
                    info "Falling back to manual setup"
                    manual_setup
                else
                    exit 1
                fi
            fi
            ;;
        setup|manual)
            manual_setup
            ;;
        nvidia|intel|amd|vesa|virtualbox|vmware)
            case "$mode" in
                nvidia) 
                    local nvidia_driver
                    nvidia_driver=$(detect_nvidia_family "$(pciconf -lv)")
                    setup_nvidia "$nvidia_driver"
                    ;;
                intel) setup_intel ;;
                amd) 
                    local amd_driver
                    amd_driver=$(detect_amd_family "$(pciconf -lv)")
                    setup_amd "$amd_driver"
                    ;;
                vesa) setup_vesa ;;
                virtualbox) setup_virtualbox ;;
                vmware) setup_vmware ;;
            esac
            ;;
        test)
            if [ -f "$XORG_CONF" ]; then
                if test_x_config "$XORG_CONF"; then
                    info "Current X configuration test passed"
                    exit 0
                else
                    error "Current X configuration test failed"
                    exit 1
                fi
            else
                error "No X configuration to test"
                exit 1
            fi
            ;;
        debug|check)
            check_system_state
            ;;
        *)
            echo "Usage: $0 [auto|setup|manual|nvidia|intel|amd|vesa|virtualbox|vmware|test|debug]" >&2
            echo "  auto      - Automatic configuration (default)" >&2
            echo "  setup     - Interactive manual setup" >&2
            echo "  manual    - Same as setup" >&2
            echo "  nvidia    - NVIDIA graphics (auto-detect driver)" >&2
            echo "  intel     - Intel graphics" >&2
            echo "  amd       - AMD graphics (auto-detect driver)" >&2
            echo "  vesa      - VESA compatible (safe mode)" >&2
            echo "  virtualbox- VirtualBox guest" >&2
            echo "  vmware    - VMware guest" >&2
            echo "  test      - Test current configuration" >&2
            echo "  debug     - Show system information" >&2
            exit 1
            ;;
    esac
}

# Execute main function
main "$@"
